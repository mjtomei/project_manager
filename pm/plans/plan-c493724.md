# PM Metrics Integration

Integrate the standalone `pulse` developer productivity agent into pm. Pulse provides
energy modeling, flow matching, break scheduling, and motivational messaging as a
generic Python package. This plan adds pm-specific trackers (project velocity, PR
rewrite ratio), wraps PRs as pulse Task objects for difficulty scoring and flow
recommendations, and surfaces everything through TUI signals, a metrics dashboard,
and notification popups.

All domain-independent functionality lives in pulse — this plan only covers the pm
integration layer that bridges pulse's generic APIs to pm's project.yaml, TUI, and
CLI.

## Vision

A pm user who gets the right PR recommended at the right time, sees their energy
level in the status bar, receives merge celebrations and break reminders as TUI
popups, and can inspect project velocity and code quality metrics from a dashboard
pane — all powered by pulse's inference engine with pm-specific data sources.

## Scope

- **Pulse dependency**: add pulse to pyproject.toml, bridge initialization
- **PM-specific trackers**: project velocity (status transitions) and PR rewrite ratio (AI code survival)
- **Task adapter**: wrap pm PRs as pulse Task objects for difficulty scoring and flow matching
- **TUI signals**: energy indicator, color temperature, merge celebration, streak counter
- **TUI dashboard**: metrics pane with velocity sparkline, energy gauge, recommendations
- **Notification integration**: TUI popup overlay for pulse notifications
- **Lifecycle**: onboarding, startup/shutdown hooks, pm-specific config defaults

## Goals

1. Surface pulse's energy and flow recommendations in the pm TUI and CLI
2. Track pm-specific signals (velocity, rewrite ratio) that pulse cannot derive on its own
3. Provide a seamless onboarding experience for pm users to opt into metrics
4. Keep the integration layer thin — delegate to pulse for all core logic

## Key Design Decisions

### Thin Wrapper Pattern
All core metrics, inference, and scheduling logic lives in pulse. The pm integration
layer is responsible only for: (1) initializing pulse with pm's data directory,
(2) implementing pm-specific Tracker subclasses, (3) adapting PRs to pulse's Task
protocol, (4) rendering pulse output in the TUI.

### PR as Task
`pm_core/metrics/task_adapter.py` wraps a pm PR dict as a pulse `Task` protocol
object: `id` → PR id, `description` → PR description, `estimated_files` → count from
files field, `dep_depth` → graph depth from pm's dependency graph, `historical_cycle_time`
→ average from velocity tracker. This lets pulse's difficulty scorer and flow matcher
work with pm PRs without pulse knowing about pm.

### Rewrite Ratio
A pm-specific signal: compares the diff at PR start (initial AI generation) vs the
final merged diff to measure how much AI-generated code survives review. High rewrite
ratio = wasted generation. This feeds back into understanding which PR types benefit
from more review iterations.

## Constraints

- Pulse must be a declared dependency, not vendored or copied
- pm integration code must only use pulse's public API (documented imports)
- TUI signals and dashboard must not degrade TUI performance
- All pm-specific trackers must implement pulse's Tracker ABC
- Metrics features are opt-in — pm works fully without pulse installed (graceful import fallback)

## PRs

### PR: Add pulse dependency and pm metrics store bridge
- **description**: Add `pulse` to pyproject.toml dependencies. Create `pm_core/metrics/__init__.py` that initializes pulse's MetricsStore with pm's data directory (`~/.pm/metrics/`), and creates a bridge so pm code can call `from pm_core.metrics import get_store, get_registry, get_energy_model` without knowing pulse internals. Create `pm_core/cli/metrics.py` with `pm metrics query`, `pm metrics energy`, and `pm metrics trackers` as thin wrappers that delegate to pulse's store, energy model, and registry respectively. Handle the case where pulse is not installed (import error → clear message suggesting `pip install pulse`).
- **tests**: bridge initialization creates store at correct path, CLI commands delegate to pulse, graceful error when pulse not installed, store bridge exposes query/record API
- **files**: pyproject.toml (modify — add pulse dependency), pm_core/metrics/__init__.py (create), pm_core/cli/metrics.py (create), pm_core/cli/__init__.py (modify — register metrics group), tests/test_metrics_bridge.py (create)
- **depends_on**:

---

### PR: Project velocity tracker
- **description**: Create `pm_core/metrics/velocity.py` implementing `pulse.Tracker`. Reads project.yaml PR entries to compute: PR cycle time (time from in_progress to merged), phase durations (pending→in_progress, in_progress→in_review, in_review→merged), throughput (PRs merged per rolling 7-day window), review loop efficiency (iterations per PR from review_loop state). Emits metrics: `velocity.cycle_time_hours`, `velocity.phase.<phase>_hours`, `velocity.throughput_7d`, `velocity.review_iterations`. Requires tracking state transitions — reads from git log of project.yaml changes as a non-invasive approach (no schema changes to project.yaml). Registers with pulse's TrackerRegistry via the pm metrics bridge. Poll interval: 10 minutes.
- **tests**: cycle time calculation from status history, throughput over rolling window, handles PRs with missing timestamps, phase duration extraction, review iteration counting
- **files**: pm_core/metrics/velocity.py (create), tests/test_velocity_tracker.py (create)
- **depends_on**: Add pulse dependency and pm metrics store bridge

---

### PR: PR rewrite ratio tracker
- **description**: Create `pm_core/metrics/rewrite_ratio.py` implementing `pulse.Tracker`. For each merged PR, compares the diff at PR creation (initial AI generation captured from the branch's first meaningful commit) against the final merge diff to measure how much AI-generated code survived review. Emits: `rewrite.ratio.<pr_id>` (0.0 = complete rewrite, 1.0 = no changes), `rewrite.lines_survived`, `rewrite.lines_changed`. Uses git diff between the branch point and first commit vs branch point and merge commit. This is the key "code quality feedback" signal — tracks how effective the initial generation is and which PR types need more review cycles. Poll interval: checks for newly merged PRs every 10 minutes.
- **tests**: rewrite ratio computation (compare two diffs), handles PRs with single commit (ratio = 1.0), handles empty diffs gracefully, correctly identifies branch point
- **files**: pm_core/metrics/rewrite_ratio.py (create), tests/test_rewrite_ratio_tracker.py (create)
- **depends_on**: Add pulse dependency and pm metrics store bridge

---

### PR: PM task adapter and flow integration
- **description**: Create `pm_core/metrics/task_adapter.py` that wraps pm PR dicts as pulse `Task` protocol objects. `PRTask` class: `id` = pr['id'], `description` = pr['description'], `estimated_files` = count of files from plan parser's files field, `dep_depth` = computed from pm's dependency graph (graph.py), `historical_cycle_time` = average cycle time from velocity tracker for PRs in the same plan. Add `pm pr list --by-difficulty` flag that gets ready PRs, wraps them as PRTask objects, scores via pulse's DifficultyScorer, and sorts by difficulty. Add `pm pr recommend` command that uses pulse's FlowMatcher to recommend the best PR to work on next, showing top 3 with difficulty match reasoning. Both commands gracefully degrade if pulse is not available.
- **tests**: PRTask wraps PR dict correctly, estimated_files extraction from plan, dep_depth computation, --by-difficulty sorting, recommend command output format, graceful fallback without pulse
- **files**: pm_core/metrics/task_adapter.py (create), pm_core/cli/pr.py (modify — add --by-difficulty flag and recommend subcommand), tests/test_task_adapter.py (create)
- **depends_on**: Add pulse dependency and pm metrics store bridge, Project velocity tracker

---

### PR: TUI interface signals
- **description**: Create `pm_core/tui/signals.py` and integrate with the TUI. Subtle, state-driven UI modifications powered by pulse's energy model: (1) **Energy indicator** — small colored dot in StatusBar reflecting current energy level (green=high, yellow=moderate, red=low), reads from pulse's `EnergyState`, (2) **Color temperature** — shift TUI CSS color variables based on energy (high focus: cooler blues/whites, winding down: warmer amber tones), applied via Textual's dynamic CSS, (3) **Merge celebration** — brief color flash or border highlight (<1s) when a PR merge is detected during sync, (4) **Streak counter** — small counter in StatusBar showing current daily PR merge streak, read from pulse's metrics store. Each signal individually toggleable in config. The signals module exposes `update_signals(app, energy_state, metrics)` called periodically by the TUI (every 30 seconds).
- **tests**: energy indicator color mapping, color temperature CSS generation for different energy levels, streak counter formatting, all signals respect individual enable/disable config, update_signals with missing energy data doesn't crash
- **files**: pm_core/tui/signals.py (create), pm_core/tui/app.py (modify — call update_signals periodically), pm_core/tui/widgets.py (modify — add energy indicator and streak counter to StatusBar), tests/test_interface_signals.py (create)
- **depends_on**: Add pulse dependency and pm metrics store bridge

---

### PR: TUI metrics dashboard and notifications
- **description**: Create `pm_core/tui/metrics_pane.py` — a new TUI view toggled with `D` key (Dashboard). Shows: (1) velocity sparkline (last 14 days of PRs merged per day), (2) energy gauge (current inferred energy as visual bar), (3) current recommendation (top recommended PR with difficulty match reasoning from flow matcher), (4) streak and stats (current streak, total PRs merged, average cycle time), (5) recent churn (top 5 most-churned files this week from pulse's code churn tracker), (6) break status (time until next suggested break from pulse's break scheduler), (7) reading suggestion (one queued item from pulse's reading list). Data pulled from pulse via the pm metrics bridge. Refreshes every 30 seconds or on manual `r` key. Also integrate pulse's notification system with the TUI: register a `CallbackBackend` that posts Textual toast notifications. Notifications styled by category (celebration: green, encouragement: blue, curiosity: purple, break: orange). Auto-dismiss after 5 seconds, queue multiple, don't block TUI input.
- **tests**: pane renders without crashing with empty metrics, sparkline generation, energy gauge formatting, key toggle (D to open, D/Escape to close), notification popup appears, auto-dismiss, category styling, doesn't block input
- **files**: pm_core/tui/metrics_pane.py (create), pm_core/tui/app.py (modify — add D keybinding, metrics toggle, notification callback registration), tests/test_metrics_pane.py (create)
- **depends_on**: PM task adapter and flow integration, TUI interface signals

---

### PR: Metrics lifecycle and onboarding
- **description**: Wire up the full metrics lifecycle in the TUI and provide first-run onboarding. On TUI `on_mount`: read pm metrics config, initialize pulse's TrackerRegistry with pm-specific trackers (velocity, rewrite ratio) plus pulse's built-in trackers, start the energy model, start the break scheduler, register the TUI notification callback. On `on_unmount`: stop all trackers, save break state. Add `pm metrics init` CLI command that creates pm-specific pulse config with sensible defaults (velocity and rewrite trackers enabled, camera/wearable disabled, notifications enabled, virtual PM enabled). When the TUI starts and metrics are not yet initialized, show a one-time onboarding screen explaining what the metrics system does and asking which optional features to enable. Add `pm metrics config` to show current configuration and `pm metrics config set <key> <value>` for quick changes.
- **tests**: init creates valid config with pm-specific defaults, onboarding screen renders, TUI lifecycle starts/stops tracker registry, handles missing config (uses defaults), handles corrupt config (resets with warning), pm-specific trackers registered alongside pulse built-ins
- **files**: pm_core/metrics/config.py (create), pm_core/cli/metrics.py (modify — add init/config commands), pm_core/tui/app.py (modify — add metrics lifecycle to mount/unmount), pm_core/tui/screens.py (modify — add MetricsOnboardingScreen), tests/test_metrics_config.py (create)
- **depends_on**: Add pulse dependency and pm metrics store bridge, Project velocity tracker, PR rewrite ratio tracker, PM task adapter and flow integration, TUI interface signals, TUI metrics dashboard and notifications
